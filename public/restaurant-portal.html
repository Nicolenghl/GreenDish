<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GreenDish - Restaurant Portal</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.4.0/dist/ethers.umd.min.js"></script>
    <script src="js/contract-config.js"></script>
    <style>
        :root {
            --primary: #1e8449;
            --primary-light: #27ae60;
            --primary-dark: #196f3d;
            --secondary: #3498db;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --danger: #e74c3c;
            --success: #27ae60;
            --warning: #f39c12;
            --info: #3498db;
            --gray: #95a5a6;
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --hover-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: var(--dark);
            line-height: 1.6;
        }

        /* Header and Navigation */
        .header {
            background-color: var(--primary);
            color: white;
            padding: 1rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .brand {
            font-size: 24px;
            font-weight: bold;
            text-decoration: none;
            color: white;
        }

        .nav-links {
            display: flex;
            gap: 10px;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .nav-links a:hover,
        .nav-links a.active {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 20px;
        }

        .page-title {
            margin-bottom: 2rem;
            color: var(--primary);
            font-weight: 600;
        }

        /* Cards */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            box-shadow: var(--hover-shadow);
        }

        .card-title {
            color: var(--primary);
            font-size: 20px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--dark);
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 15px;
            transition: all 0.3s;
            background-color: var(--light);
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.1);
        }

        /* Button Styles */
        .btn {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            background-color: #2980b9;
        }

        .btn-warning {
            background-color: var(--warning);
        }

        .btn-warning:hover {
            background-color: #e67e22;
        }

        .btn-danger {
            background-color: var(--danger);
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        /* Connection Status */
        .connection-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background-color: rgba(52, 152, 219, 0.05);
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .wallet-address {
            font-weight: 600;
            color: var(--dark);
            background-color: var(--light);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
        }

        /* Alerts */
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 6px;
            font-weight: 500;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-success {
            background-color: rgba(46, 204, 113, 0.1);
            color: var(--success);
            border-left: 4px solid var(--success);
        }

        .alert-error {
            background-color: rgba(231, 76, 60, 0.1);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .alert-warning {
            background-color: rgba(243, 156, 18, 0.1);
            color: var(--warning);
            border-left: 4px solid var(--warning);
        }

        .alert-info {
            background-color: rgba(52, 152, 219, 0.1);
            color: var(--info);
            border-left: 4px solid var(--info);
        }

        /* Dish Items */
        .dish-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .dish-item {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            border-top: 5px solid var(--primary);
        }

        .dish-item:hover {
            transform: translateY(-5px);
            box-shadow: var(--hover-shadow);
        }

        .dish-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .dish-title {
            color: var(--primary);
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }

        .dish-address {
            font-family: monospace;
            background-color: var(--light);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            word-break: break-all;
            margin: 10px 0;
        }

        .dish-specs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .dish-spec {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
        }

        .dish-spec-title {
            display: block;
            margin-bottom: 5px;
            color: var(--gray);
            font-size: 12px;
            text-transform: uppercase;
        }

        .dish-spec-value {
            color: var(--dark);
            font-weight: 600;
            font-size: 16px;
        }

        .dish-actions {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .action-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .action-row label {
            margin: 0;
            min-width: 100px;
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-success {
            background-color: rgba(46, 204, 113, 0.1);
            color: var(--success);
        }

        .badge-danger {
            background-color: rgba(231, 76, 60, 0.1);
            color: var(--danger);
        }

        /* Stats Section */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            text-align: center;
        }

        .stat-title {
            color: var(--gray);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .stat-value {
            color: var(--primary);
            font-size: 24px;
            font-weight: 600;
        }

        /* Consumption Stats */
        .consumption-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #f0f0f0;
        }

        .stats-title {
            font-size: 16px;
            color: var(--dark);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .progress-container {
            background-color: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            width: 100%;
            margin-bottom: 5px;
        }

        .progress-bar {
            height: 8px;
            border-radius: 10px;
            background-color: var(--primary);
        }

        /* Owner Info */
        .owner-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .owner-address {
            font-family: monospace;
        }

        /* Responsive Design */
        @media (max-width: 992px) {
            .dish-list {
                grid-template-columns: 1fr;
            }

            .stats-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .stats-container {
                grid-template-columns: 1fr;
            }

            .action-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .dish-specs {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Add additional styling for sold out dishes */
        .sold-out {
            position: relative;
            opacity: 0.9;
        }

        .sold-out::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed var(--danger);
            pointer-events: none;
            border-radius: 8px;
        }

        /* Carbon Report Styles */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .table th,
        .table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #f0f0f0;
        }

        .table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: var(--dark);
        }

        .table tr:hover {
            background-color: rgba(46, 204, 113, 0.05);
        }

        .table-responsive {
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .table-warning {
            background-color: rgba(243, 156, 18, 0.1);
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        #export-options {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        #carbon-credits-chart {
            transition: all 0.3s ease;
        }

        #carbon-credits-chart:hover {
            box-shadow: var(--hover-shadow);
        }

        /* Helper text styling */
        .form-text {
            font-size: 13px;
            margin-top: 5px;
            display: block;
        }

        .text-muted {
            color: #6c757d;
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="brand">GreenDish</a>
                <div class="nav-links">
                    <a href="index.html">Home</a>
                    <a href="marketplace.html">Marketplace</a>
                    <a href="customer-profile.html">My Profile</a>
                    <a href="restaurant-portal.html" class="active">Restaurant Portal</a>
                </div>
            </div>
        </div>
    </header>

    <div class="main-content">
        <h1 class="page-title">Restaurant Dashboard</h1>

        <!-- Back to Main button -->
        <div style="margin-bottom: 20px; text-align: right;">
            <a href="index.html" class="btn" style="background-color: #3498db;">
                <span style="margin-right: 5px;">↩</span> Back to Main Page
            </a>
        </div>

        <!-- Network warning banner -->
        <div id="network-warning" class="alert alert-warning" style="display: none;">
            <strong>Network Issue Detected:</strong> Your connection to the local blockchain might be lost or using
            incorrect contract addresses.
            If you're having problems, follow these steps:
            <ol style="margin-top: 10px; margin-bottom: 5px;">
                <li>Refresh the page</li>
                <li><strong>Reset your MetaMask account:</strong>
                    <ul>
                        <li>Open MetaMask</li>
                        <li>Click on the account icon (top right) → Settings → Advanced</li>
                        <li>Scroll down and click "Reset Account"</li>
                        <li>Confirm the reset</li>
                    </ul>
                </li>
                <li>Make sure MetaMask is connected to <strong>Localhost 8545</strong> network</li>
                <li>Reconnect your wallet on this page</li>
            </ol>
            <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button onclick="document.getElementById('network-warning').style.display='none'"
                    class="btn btn-small">Dismiss</button>
                <button onclick="checkContractAddresses()" class="btn btn-secondary btn-small">Debug Contract
                    Addresses</button>
                <button onclick="resetAndReconnect()" class="btn btn-warning btn-small">Reset Connection</button>
                <button onclick="hardReset()" class="btn btn-danger btn-small">Hard Reset</button>
            </div>
            <div id="debug-info"
                style="display: none; margin-top: 10px; padding: 10px; background-color: #f8f8f8; border-radius: 4px; font-family: monospace; font-size: 12px;">
            </div>
        </div>

        <div class="connection-status card">
            <div>
                <h3 class="card-title" style="margin-bottom: 5px; border-bottom: none;">Wallet Status</h3>
                <span id="wallet-status" class="wallet-address">Not connected</span>
            </div>
            <button id="connect-wallet" class="btn">Connect Wallet</button>
        </div>

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-title">Registered Dishes</div>
                <div id="registered-dishes" class="stat-value">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Current Inventory</div>
                <div id="total-inventory" class="stat-value">0</div>
                <div class="stat-subtitle" style="font-size: 12px; color: var(--gray); margin-top: 5px;">Currently
                    available</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Inventory Reduction</div>
                <div id="sold-items" class="stat-value">0</div>
                <div class="stat-subtitle" style="font-size: 12px; color: var(--gray); margin-top: 5px;">Since last
                    inventory reset</div>
            </div>
            <div class="stat-card"
                style="background-color: rgba(39, 174, 96, 0.1); border-left: 4px solid var(--primary);">
                <div class="stat-title">GreenCoin Balance</div>
                <div id="token-balance" class="stat-value">0</div>
            </div>
        </div>

        <!-- Hidden element for backward compatibility -->
        <div id="active-dishes" style="display:none">0</div>

        <!-- Carbon Credits Report Section -->
        <div class="card">
            <h2 class="card-title">Carbon Credits Report</h2>
            <div class="alert alert-info">
                <strong>Sustainability Tracking:</strong> This report helps track the carbon credits consumed by
                customers, useful for ESG reporting and sustainability initiatives.
            </div>

            <div class="section-title" style="margin-top: 20px;">
                <h3>Carbon Credits Summary</h3>
                <button id="generate-report" class="btn btn-secondary">Generate Report</button>
            </div>

            <div class="stats-container" style="margin-bottom: 30px;">
                <div class="stat-card">
                    <div class="stat-title">Total Carbon Credits</div>
                    <div id="total-carbon-credits" class="stat-value">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Restaurant Tier</div>
                    <div id="restaurant-tier" class="stat-value">Basic</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Dishes Sold</div>
                    <div id="total-dishes-sold" class="stat-value">0</div>
                    <div class="stat-subtitle" style="font-size: 12px; color: var(--gray); margin-top: 5px;">Tracked
                        from transactions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Actual Sales</div>
                    <div id="actual-sales" class="stat-value">0</div>
                    <div class="stat-subtitle" style="font-size: 12px; color: var(--gray); margin-top: 5px;">From
                        customer purchases only</div>
                </div>
            </div>

            <!-- Add back average credits per sale element that's referenced in JS -->
            <div id="avg-carbon-credits" style="display:none"></div>

            <div id="carbon-credits-chart"
                style="width: 100%; height: 300px; background-color: #f8f9fa; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                <p>Carbon credits data chart will appear here after generating the report</p>
            </div>

            <div style="margin-top: 20px;">
                <h3>Detailed Transaction History</h3>
                <div class="table-responsive">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Dish Name</th>
                                <th>Buyer Address</th>
                                <th>Quantity</th>
                                <th>Carbon Credits</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="carbon-transactions">
                            <tr>
                                <td colspan="5" style="text-align: center;">Generate a report to see transaction history
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div style="margin-top: 20px; display: none;" id="export-options">
                <button id="export-csv" class="btn btn-secondary">Export Report as CSV</button>
            </div>
        </div>

        <!-- Restaurant Loyalty Status -->
        <div class="card">
            <h2 class="card-title">Restaurant Sustainability Tier</h2>
            <div class="alert alert-info">
                <strong>Sustainability Ranking:</strong> Your restaurant's tier level based on accumulated carbon
                impact.
            </div>

            <div id="restaurant-tier-info">
                <div class="stats-container" style="margin-bottom: 20px;">
                    <div class="stat-card">
                        <div class="stat-title">Current Tier</div>
                        <div id="restaurant-current-tier" class="stat-value">GREEN BASIC</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Reward Multiplier</div>
                        <div id="restaurant-multiplier" class="stat-value">1.0x</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Carbon Impact</div>
                        <div id="restaurant-carbon-impact" class="stat-value">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Next Tier Threshold</div>
                        <div id="restaurant-next-tier" class="stat-value">2500</div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                        <span>Progress to Next Tier</span>
                        <span id="tier-progress-percent">0%</span>
                    </div>
                    <div class="progress-container">
                        <div id="tier-progress-bar" class="progress-bar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="deploy-form" class="card">
            <h2 class="card-title">Create New Dish</h2>
            <div class="alert alert-warning">
                <strong>Note:</strong> As the owner, you will not be able to purchase dishes from your own contracts.
                This is to ensure fair market practices.
            </div>
            <div class="form-group">
                <label for="restaurant-name">Restaurant Name:</label>
                <input type="text" id="restaurant-name" placeholder="Enter restaurant name" required>
                <small id="restaurant-name-help" class="form-text text-muted">
                    Once set, your restaurant name will be saved for future dishes you create.
                </small>
            </div>
            <div class="form-group">
                <label for="dish-name">Dish Name:</label>
                <input type="text" id="dish-name" placeholder="Enter dish name" required>
            </div>
            <div class="form-group">
                <label for="dish-price">Dish Price (in ETH):</label>
                <input type="number" id="dish-price" step="0.001" min="0.001" placeholder="Enter dish price in ETH"
                    required>
            </div>
            <div class="form-group">
                <label for="inventory">Initial Inventory:</label>
                <input type="number" id="inventory" min="1" max="10000"
                    placeholder="Enter initial inventory amount (max 10000)" required>
            </div>
            <div class="form-group">
                <label for="carbon-credits">Carbon Credits (0-100):</label>
                <input type="number" id="carbon-credits" min="0" max="100"
                    placeholder="Enter carbon credits per dish (0-100)" required>
            </div>
            <div class="form-group">
                <label for="main-component">Main Component:</label>
                <input type="text" id="main-component" placeholder="Enter main component" required>
            </div>
            <div class="form-group">
                <label for="supply-source">Supply Source:</label>
                <input type="text" id="supply-source" placeholder="Enter supply source" required>
            </div>
            <button id="deploy-contract" class="btn btn-block">CREATE NEW DISH CONTRACT</button>
        </div>

        <div id="status-messages"></div>

        <div class="card">
            <h2 class="card-title">Your Deployed Dish Contracts</h2>
            <div id="dish-list">
                <p>Connect your wallet to see deployed contracts</p>
            </div>
        </div>
    </div>

    <script>
        // Add this function as a helper at the top of the script section to handle ethers.js version differences
        function parseEther(amount) {
            // Support both ethers v5 (utils.parseEther) and v6 (parseEther) syntax
            return ethers.parseEther ? ethers.parseEther(amount) : ethers.utils.parseEther(amount);
        }

        // Elements
        const connectWalletBtn = document.getElementById('connect-wallet');
        const walletStatus = document.getElementById('wallet-status');
        const restaurantNameInput = document.getElementById('restaurant-name');
        const dishNameInput = document.getElementById('dish-name');
        const dishPriceInput = document.getElementById('dish-price');
        const inventoryInput = document.getElementById('inventory');
        const carbonCreditsInput = document.getElementById('carbon-credits');
        const mainComponentInput = document.getElementById('main-component');
        const supplySourceInput = document.getElementById('supply-source');
        const deployContractBtn = document.getElementById('deploy-contract');
        const statusMessages = document.getElementById('status-messages');
        const dishList = document.getElementById('dish-list');
        const registeredDishesElement = document.getElementById('registered-dishes');
        // Keep total-dishes reference for backward compatibility
        const totalDishesElement = registeredDishesElement;
        const activeDishesElement = document.getElementById('active-dishes');
        const totalInventoryElement = document.getElementById('total-inventory');
        const soldItemsElement = document.getElementById('sold-items');
        const generateReportBtn = document.getElementById('generate-report');
        const exportCsvBtn = document.getElementById('export-csv');

        // Restaurant tier elements
        const restaurantCurrentTier = document.getElementById('restaurant-current-tier');
        const restaurantMultiplier = document.getElementById('restaurant-multiplier');
        const restaurantCarbonImpact = document.getElementById('restaurant-carbon-impact');
        const restaurantNextTier = document.getElementById('restaurant-next-tier');
        const tierProgressPercent = document.getElementById('tier-progress-percent');
        const tierProgressBar = document.getElementById('tier-progress-bar');

        // State
        let web3;
        let accounts = [];
        let greenDishContract;
        let deployedDishes = [];
        let purchaseEvents = [];
        let restaurantTier = 0;
        let actualSalesCount = 0;

        // Initialize
        window.addEventListener('load', init);

        // Initialize app
        function init() {
            connectWalletBtn.addEventListener('click', connectWallet);
            deployContractBtn.addEventListener('click', createDish);
            generateReportBtn.addEventListener('click', generateCarbonReport);
            exportCsvBtn.addEventListener('click', exportCarbonReportCSV);

            // Check if we have a saved restaurant name for this wallet
            loadSavedRestaurantName();
        }

        // Load saved restaurant name from localStorage
        function loadSavedRestaurantName() {
            if (accounts.length > 0) {
                const accountKey = accounts[0].toLowerCase();
                const savedData = localStorage.getItem(`restaurantInfo_${accountKey}`);

                // Clear the restaurant name input and reset its attributes first
                restaurantNameInput.value = '';
                restaurantNameInput.removeAttribute('readonly');

                // Remove change name button if it exists
                const changeNameBtn = document.getElementById('change-name-btn');
                if (changeNameBtn) {
                    changeNameBtn.remove();
                }

                if (savedData) {
                    try {
                        const restaurantInfo = JSON.parse(savedData);
                        if (restaurantInfo.name) {
                            restaurantNameInput.value = restaurantInfo.name;
                            // Make the field readonly to prevent accidental changes
                            restaurantNameInput.setAttribute('readonly', true);

                            // Add a button to allow changing the name if needed
                            const nameContainer = restaurantNameInput.parentElement;
                            if (!document.getElementById('change-name-btn')) {
                                const changeNameBtn = document.createElement('button');
                                changeNameBtn.id = 'change-name-btn';
                                changeNameBtn.className = 'btn btn-secondary';
                                changeNameBtn.style.marginTop = '10px';
                                changeNameBtn.textContent = 'Change Restaurant Name';
                                changeNameBtn.addEventListener('click', function () {
                                    restaurantNameInput.removeAttribute('readonly');
                                    restaurantNameInput.focus();
                                    this.style.display = 'none';
                                });
                                nameContainer.appendChild(changeNameBtn);
                            }
                        }
                    } catch (e) {
                        console.error("Error parsing saved restaurant info:", e);
                    }
                }
            } else {
                // Clear the input if no account is connected
                restaurantNameInput.value = '';
                restaurantNameInput.removeAttribute('readonly');
            }
        }

        // Connect wallet
        async function connectWallet() {
            if (window.ethereum) {
                try {
                    // Clean up any existing change name button before connecting
                    const existingChangeNameBtn = document.getElementById('change-name-btn');
                    if (existingChangeNameBtn) {
                        existingChangeNameBtn.remove();
                    }

                    // Reset restaurant name input
                    restaurantNameInput.value = '';
                    restaurantNameInput.removeAttribute('readonly');

                    // Use the shared configuration to initialize Web3
                    if (await GreenDishConfig.initWeb3()) {
                        web3 = window.web3;
                        accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });

                        walletStatus.textContent = `${accounts[0].substring(0, 6)}...${accounts[0].substring(38)}`;
                        showAlert("Wallet connected successfully!", "success");

                        // Use the contract instance from the shared config
                        greenDishContract = GreenDishConfig.greenDishContract;

                        // Hide network warning if it was shown
                        document.getElementById('network-warning').style.display = 'none';

                        // Load restaurant data
                        loadRestaurantData();

                        // Setup event listeners for blockchain events
                        setupEventListeners();

                        // Load any saved restaurant name
                        loadSavedRestaurantName();

                        // Listen for account changes
                        window.ethereum.on('accountsChanged', function (newAccounts) {
                            accounts = newAccounts;
                            walletStatus.textContent = accounts.length > 0 ?
                                `${accounts[0].substring(0, 6)}...${accounts[0].substring(38)}` :
                                "Not connected";

                            // Clear all input fields except restaurant name (which will be loaded if available)
                            dishNameInput.value = '';
                            dishPriceInput.value = '';
                            inventoryInput.value = '';
                            carbonCreditsInput.value = '';
                            mainComponentInput.value = '';
                            supplySourceInput.value = '';

                            if (accounts.length > 0) {
                                loadRestaurantData();
                                loadSavedRestaurantName(); // This will now properly load the name for the new account
                            } else {
                                showAlert("Wallet disconnected", "warning");
                                // Clear restaurant name input when disconnected
                                restaurantNameInput.value = '';
                                restaurantNameInput.removeAttribute('readonly');

                                // Clear dish list and stats when disconnected
                                dishList.innerHTML = "<p>Connect your wallet to see deployed contracts</p>";
                                updateDashboardStats();
                            }
                        });

                        // Listen for network changes
                        window.ethereum.on('chainChanged', function () {
                            showAlert("Network changed. Refreshing...", "info");
                            setTimeout(() => { window.location.reload(); }, 1000);
                        });

                        // Listen for disconnect
                        window.ethereum.on('disconnect', function (error) {
                            console.error('MetaMask disconnected:', error);
                            document.getElementById('network-warning').style.display = 'block';
                            showAlert("Connection to blockchain lost!", "error");
                        });
                    } else {
                        throw new Error("Failed to initialize Web3");
                    }
                } catch (error) {
                    console.error("Error connecting wallet:", error);
                    showAlert("Error connecting wallet. Please try again.", "error");
                    document.getElementById('network-warning').style.display = 'block';
                }
            } else {
                showAlert("Please install MetaMask or another Web3 provider to use this application", "error");
            }
        }

        // Load restaurant data
        async function loadRestaurantData() {
            if (!greenDishContract || !accounts.length) return;

            try {
                // Get dishes created by the restaurant owner
                const ownerDishes = await greenDishContract.methods.getRestaurantDishes(accounts[0]).call();
                console.log("Restaurant dishes:", ownerDishes);

                // Load restaurant loyalty tier info
                loadRestaurantTierInfo();

                // Count actual sales if the element exists
                if (document.getElementById('actual-sales')) {
                    await countActualSales();
                }

                // Reset dishes array
                deployedDishes = [];

                // Load saved initial inventory data if available
                let savedInitialInventory = {};
                try {
                    const savedData = localStorage.getItem(`initialInventory_${accounts[0].toLowerCase()}`);
                    if (savedData) {
                        savedInitialInventory = JSON.parse(savedData);
                        console.log("Loaded saved initial inventory:", savedInitialInventory);
                    }
                } catch (e) {
                    console.error("Error loading saved inventory data:", e);
                }

                // Load dish details
                if (ownerDishes.length > 0) {
                    let restaurantNameFromChain = null;

                    for (const dishId of ownerDishes) {
                        try {
                            const dishInfo = await greenDishContract.methods.getDishInfo(dishId).call();
                            console.log(`Dish ${dishId} info:`, dishInfo);

                            // Store restaurant name from first dish if we don't have it yet
                            if (!restaurantNameFromChain && dishInfo[0]) {
                                restaurantNameFromChain = dishInfo[0];
                            }

                            const dish = {
                                id: dishId,
                                restaurantName: dishInfo[0],
                                restaurantOwner: dishInfo[1],
                                name: dishInfo[2],
                                dishPrice: web3.utils.fromWei(dishInfo[3], 'ether'),
                                availableInventory: dishInfo[4],
                                carbonCredits: dishInfo[5],
                                mainComponent: dishInfo[6],
                                supplySource: dishInfo[7],
                                isActive: dishInfo[8]
                            };

                            // If we have saved initial inventory, use it
                            // Otherwise, use current inventory as the initial value
                            if (savedInitialInventory[dishId]) {
                                dish.totalSeats = savedInitialInventory[dishId];
                            } else {
                                // This is a new dish or we don't have saved data
                                // Save the current inventory as the initial value
                                dish.totalSeats = dish.availableInventory;
                                savedInitialInventory[dishId] = dish.availableInventory;
                            }

                            deployedDishes.push(dish);
                        } catch (error) {
                            console.error(`Error loading dish ${dishId}:`, error);
                        }
                    }

                    // Save the updated initial inventory values to localStorage
                    try {
                        localStorage.setItem(`initialInventory_${accounts[0].toLowerCase()}`, JSON.stringify(savedInitialInventory));
                    } catch (e) {
                        console.error("Error saving inventory data:", e);
                    }

                    // If we found a restaurant name on-chain but don't have one saved, save it
                    if (restaurantNameFromChain) {
                        const savedData = localStorage.getItem(`restaurantInfo_${accounts[0].toLowerCase()}`);
                        if (!savedData) {
                            saveRestaurantName(restaurantNameFromChain);
                            showAlert(`Retrieved your restaurant name "${restaurantNameFromChain}" from your existing dishes`, "info");
                        }
                    }

                    // Update UI
                    renderDishList();
                    updateDashboardStats();

                    showAlert(`Loaded ${deployedDishes.length} dishes`, "success");
                } else {
                    dishList.innerHTML = "<p>No dishes created yet</p>";
                    updateDashboardStats();
                }
            } catch (error) {
                console.error("Error loading restaurant data:", error);
                showAlert("Error loading restaurant data: " + error.message, "error");
            }
        }

        // Load restaurant tier info
        async function loadRestaurantTierInfo() {
            if (!greenDishContract || !accounts.length) return;

            try {
                const tierInfo = await greenDishContract.methods.getRestaurantLoyaltyInfo(accounts[0]).call();
                console.log("Restaurant tier info:", tierInfo);

                // Extract tier information
                const tierLevel = parseInt(tierInfo[0]);
                const multiplier = parseInt(tierInfo[1]);
                const carbonImpact = parseInt(tierInfo[2]);
                const nextTierThreshold = parseInt(tierInfo[3]);

                // Map tier enum to human-readable names
                const tierNames = ["GREEN BASIC", "GREEN PLUS", "GREEN ELITE", "GREEN MASTER"];

                // Update UI
                restaurantCurrentTier.textContent = tierNames[tierLevel] || "GREEN BASIC";
                restaurantMultiplier.textContent = (multiplier / 100).toFixed(2) + "x";
                restaurantCarbonImpact.textContent = carbonImpact;

                // Handle next tier threshold
                if (nextTierThreshold > 0) {
                    restaurantNextTier.textContent = nextTierThreshold;

                    // Calculate progress percentage
                    const progress = Math.min(100, Math.round((carbonImpact / nextTierThreshold) * 100));
                    tierProgressPercent.textContent = progress + "%";
                    tierProgressBar.style.width = progress + "%";
                } else {
                    // Already at highest tier
                    restaurantNextTier.textContent = "MAX";
                    tierProgressPercent.textContent = "100%";
                    tierProgressBar.style.width = "100%";
                }

                // Get restaurant token balance (must explicitly get from GreenCoin contract)
                if (window.web3 && accounts.length > 0) {
                    try {
                        // Create GreenCoin contract if needed
                        if (!GreenDishConfig.greenCoinContract) {
                            const greenCoinAddress = GreenDishConfig.addresses.GreenCoin;
                            if (greenCoinAddress) {
                                GreenDishConfig.greenCoinContract = new window.web3.eth.Contract(
                                    GreenDishConfig.greenCoinABI,
                                    greenCoinAddress
                                );
                            }
                        }

                        if (GreenDishConfig.greenCoinContract) {
                            const tokenBalance = await GreenDishConfig.greenCoinContract.methods.balanceOf(accounts[0]).call();
                            const formattedBalance = web3.utils.fromWei(tokenBalance, 'ether');

                            // Add token balance to the UI with proper formatting (show 2 decimal places)
                            const tokenBalanceElement = document.getElementById('token-balance');
                            if (tokenBalanceElement) {
                                // Format to show 2 decimal places for readability
                                const displayBalance = parseFloat(formattedBalance).toLocaleString(undefined, {
                                    minimumFractionDigits: 0,
                                    maximumFractionDigits: 2
                                });
                                tokenBalanceElement.textContent = displayBalance;
                                console.log("Restaurant token balance:", displayBalance, "GRC");
                            }
                        } else {
                            console.error("GreenCoin contract not available");
                        }
                    } catch (e) {
                        console.error("Error getting token balance:", e);
                    }
                }
            } catch (error) {
                console.error("Error loading restaurant tier info:", error);
                // Set default values in case of error
                restaurantCurrentTier.textContent = "GREEN BASIC";
                restaurantMultiplier.textContent = "1.00x";
                restaurantCarbonImpact.textContent = "0";
                restaurantNextTier.textContent = "2500";
                tierProgressPercent.textContent = "0%";
                tierProgressBar.style.width = "0%";
            }
        }

        // Update dashboard statistics
        function updateDashboardStats() {
            const totalDishes = deployedDishes.length;
            const activeDishes = deployedDishes.filter(dish => dish.isActive).length;
            let totalInventory = 0;
            let soldItems = 0;

            // Calculate inventory and sold items
            deployedDishes.forEach(dish => {
                // For current inventory, just use the available inventory
                const availableInventory = parseInt(dish.availableInventory) || 0;
                // For computing reduction, use the initial inventory (totalSeats) if available
                const initialInventory = parseInt(dish.totalSeats) || parseInt(dish.availableInventory) || 0;

                // Total inventory is now simply the sum of all currently available inventory
                totalInventory += availableInventory;
                // Reduction is still computed from initial minus current
                soldItems += (initialInventory - availableInventory);

                console.log(`Dish ${dish.name}: Initial=${initialInventory}, Available=${availableInventory}, Inventory Reduction=${initialInventory - availableInventory}`);
            });

            // Update UI
            if (totalDishesElement) {
                totalDishesElement.textContent = totalDishes;
            }

            if (activeDishesElement) {
                activeDishesElement.textContent = activeDishes;
            }

            if (totalInventoryElement) {
                totalInventoryElement.textContent = totalInventory;
            }

            if (soldItemsElement) {
                soldItemsElement.textContent = soldItems;
            }

            // Update the actual sales display if available
            const actualSalesElement = document.getElementById('actual-sales');
            if (actualSalesElement) {
                actualSalesElement.textContent = actualSalesCount || "0";
            }
        }

        // Render dish list
        function renderDishList() {
            if (deployedDishes.length === 0) {
                dishList.innerHTML = "<p>No dishes created yet</p>";
                return;
            }

            let html = "";

            for (let index = 0; index < deployedDishes.length; index++) {
                const dish = deployedDishes[index];
                const totalInventory = dish.totalSeats || 0;
                const availableInventory = dish.availableInventory || 0;
                const soldCount = totalInventory - availableInventory;
                const consumptionPercentage = totalInventory > 0 ? (soldCount / totalInventory) * 100 : 0;

                html += `
                <div class="dish-item ${availableInventory == 0 ? 'sold-out' : ''}">
                    <div class="dish-header">
                        <h3 class="dish-title">${dish.name}</h3>
                        <span class="badge ${dish.isActive ? 'badge-success' : 'badge-danger'}">
                            ${dish.isActive ? 'Active' : 'Inactive'}
                        </span>
                        ${availableInventory == 0 ? '<span class="badge badge-danger">Sold Out</span>' : ''}
                    </div>
                    
                    <div>Dish ID: <span class="dish-address">${dish.id}</span></div>
                    
                    <div class="dish-specs">
                        <div class="dish-spec">
                            <span class="dish-spec-title">Price</span>
                            <span class="dish-spec-value">${dish.dishPrice} ETH</span>
                        </div>
                        <div class="dish-spec">
                            <span class="dish-spec-title">Inventory</span>
                            <span class="dish-spec-value">${totalInventory}</span>
                        </div>
                        <div class="dish-spec">
                            <span class="dish-spec-title">Carbon Credits</span>
                            <span class="dish-spec-value">${dish.carbonCredits}</span>
                        </div>
                        <div class="dish-spec">
                            <span class="dish-spec-title">Component</span>
                            <span class="dish-spec-value">${dish.mainComponent}</span>
                        </div>
                        <div class="dish-spec">
                            <span class="dish-spec-title">Source</span>
                            <span class="dish-spec-value">${dish.supplySource}</span>
                        </div>
                    </div>
                    
                    <div class="consumption-stats">
                        <h4 class="stats-title">Consumption Statistics</h4>
                        <div class="dish-specs">
                        <div class="dish-spec">
                                <span class="dish-spec-title">Available</span>
                                <span class="dish-spec-value">${availableInventory}</span>
                            </div>
                            <div class="dish-spec">
                                <span class="dish-spec-title">Inventory Reduction</span>
                                <span class="dish-spec-title" style="color: var(--gray); font-size: 10px; text-transform: none;">
                                    (since last reset)
                                </span>
                                <span class="dish-spec-value">${soldCount}</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                                <span>Reduction Rate</span>
                                <span>${Math.round(consumptionPercentage)}%</span>
                            </div>
                            <div class="progress-container">
                                <div class="progress-bar" style="width: ${consumptionPercentage}%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="dish-actions">
                        <div class="action-row">
                            <label>Update Inventory:</label>
                            <input type="number" min="0" max="10000" placeholder="New inventory" id="inventory-${index}">
                            <button onclick="updateDishInventory(${dish.id}, ${index})" class="btn">Update</button>
                        </div>
                        <div class="action-row">
                            <label>Dish Status:</label>
                            <select id="status-${index}" style="flex: 1;">
                                <option value="true" ${dish.isActive ? 'selected' : ''}>Active</option>
                                <option value="false" ${!dish.isActive ? 'selected' : ''}>Inactive</option>
                            </select>
                            <button onclick="toggleDishStatus(${dish.id}, ${index})" class="btn btn-warning">Update Status</button>
                        </div>
                    </div>
                </div>
                `;
            }

            dishList.innerHTML = html;
        }

        // Show an alert message
        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.classList.add('alert');
            alert.classList.add('alert-' + (type || 'info'));
            alert.textContent = message;

            statusMessages.innerHTML = '';
            statusMessages.appendChild(alert);

            // Remove alert after 5 seconds
            setTimeout(() => {
                alert.remove();
            }, 5000);
        }

        // Function to update inventory
        async function updateDishInventory(dishId, index) {
            if (accounts.length === 0 || !greenDishContract) {
                showAlert("Please connect your wallet first", "error");
                return;
            }

            const inventoryInput = document.getElementById(`inventory-${index}`);
            const newInventory = inventoryInput.value.trim();

            if (!newInventory) {
                showAlert("Please enter a new inventory value", "error");
                return;
            }

            // Add extra validation to ensure we have a valid integer
            if (!/^\d+$/.test(newInventory)) {
                showAlert("Please enter a valid whole number for inventory", "error");
                return;
            }

            const numericInventory = parseInt(newInventory);
            if (isNaN(numericInventory) || numericInventory < 0) {
                showAlert("Inventory cannot be negative and must be a valid number", "error");
                return;
            }

            try {
                showAlert("Updating inventory... Please confirm the transaction in MetaMask", "success");
                console.log(`Attempting to update inventory for dish ID ${dishId} to ${numericInventory}`);

                try {
                    // We need to handle inventory changes carefully to track sales
                    // Get the current dish info before updating
                    const currentDishInfo = await greenDishContract.methods.getDishInfo(dishId).call();
                    const currentInventory = parseInt(currentDishInfo[4]) || 0;
                    console.log(`Current inventory for dish ${dishId}: ${currentInventory}`);

                    // Load saved initial inventory data
                    let savedInitialInventory = {};
                    try {
                        const savedData = localStorage.getItem(`initialInventory_${accounts[0].toLowerCase()}`);
                        if (savedData) {
                            savedInitialInventory = JSON.parse(savedData);
                        }
                    } catch (e) {
                        console.error("Error loading saved inventory data:", e);
                    }

                    // Check if this is a manual increase in inventory
                    if (numericInventory > currentInventory) {
                        // This is a restock - update the saved total seats accordingly
                        const previousInitial = savedInitialInventory[dishId] || currentInventory;
                        const difference = numericInventory - currentInventory;
                        savedInitialInventory[dishId] = previousInitial + difference;
                        console.log(`Restocking dish ${dishId}: adding ${difference} to initial inventory`);
                    }

                    // Call the updateInventory function on the restaurant contract 
                    const tx = await greenDishContract.methods.updateInventory(dishId, numericInventory).send({ from: accounts[0] });

                    showAlert("Transaction submitted. Waiting for confirmation...", "success");
                    console.log("Transaction submitted:", tx.transactionHash);

                    // Transaction is already confirmed when we get here with Web3.js
                    console.log("Transaction confirmed!");

                    // Save the updated initial inventory values to localStorage
                    try {
                        localStorage.setItem(`initialInventory_${accounts[0].toLowerCase()}`, JSON.stringify(savedInitialInventory));
                    } catch (e) {
                        console.error("Error saving inventory data:", e);
                    }

                    // Update the UI and stored data
                    deployedDishes[index].availableInventory = numericInventory;
                    // If we're restocking, update the totalSeats as well
                    deployedDishes[index].totalSeats = savedInitialInventory[dishId] || numericInventory;

                    saveDeployedDishes();

                    // Reload dish data from contract
                    loadRestaurantData();

                    showAlert(`Inventory successfully updated to ${numericInventory}`, "success");

                    // Clear input
                    inventoryInput.value = '';
                } catch (error) {
                    console.error("Transaction error details:", error);

                    // Provide a more detailed error message
                    let errorMessage = "Error updating inventory";

                    if (error.reason) {
                        errorMessage += `: ${error.reason}`;
                    } else if (error.message) {
                        errorMessage += `: ${error.message}`;
                    }

                    // Log detailed error information
                    if (error.data) console.error("Error data:", error.data);
                    if (error.code) console.error("Error code:", error.code);

                    showAlert(errorMessage, "error");
                }
            } catch (error) {
                console.error("Setup error:", error);
                showAlert("Error setting up contract interaction: " + error.message, "error");
            }
        }

        // Function to toggle dish status
        async function toggleDishStatus(dishId, index) {
            if (accounts.length === 0 || !greenDishContract) {
                showAlert("Please connect your wallet first", "error");
                return;
            }

            const statusSelect = document.getElementById(`status-${index}`);
            const newStatus = statusSelect.value === 'true';

            try {
                showAlert(`Updating dish status to ${newStatus ? 'Active' : 'Inactive'}... Please confirm the transaction in MetaMask`, "success");

                try {
                    // Call the setDishStatus function on the restaurant contract
                    const tx = await greenDishContract.methods.setDishStatus(dishId, newStatus).send({ from: accounts[0] });

                    showAlert("Transaction submitted. Waiting for confirmation...", "success");
                    console.log("Transaction submitted:", tx.transactionHash);

                    // Transaction is already confirmed when we get here with Web3.js
                    console.log("Transaction confirmed!");

                    // Update the UI and stored data
                    deployedDishes[index].isActive = newStatus;
                    saveDeployedDishes();
                    renderDishList();
                    updateDashboardStats();

                    showAlert(`Dish status successfully updated to ${newStatus ? 'Active' : 'Inactive'}`, "success");
                } catch (error) {
                    console.error("Transaction error details:", error);

                    // Provide a more detailed error message
                    let errorMessage = "Error updating dish status";

                    if (error.reason) {
                        errorMessage += `: ${error.reason}`;
                    } else if (error.message) {
                        errorMessage += `: ${error.message}`;
                    }

                    showAlert(errorMessage, "error");
                }
            } catch (error) {
                console.error("Setup error:", error);
                showAlert("Error setting up contract interaction: " + error.message, "error");
            }
        }

        // Add a new function to listen for blockchain events that would affect dish status
        async function setupEventListeners() {
            if (!greenDishContract || accounts.length === 0) {
                return;
            }

            try {
                console.log("Setting up polling for contract changes instead of events");

                // Instead of using events, set up a simple polling mechanism
                // Poll every 10 seconds to check for new dishes or changes
                setInterval(checkForContractChanges, 10000);

            } catch (error) {
                console.error("Error setting up event listeners:", error);
            }
        }

        // Function to check for changes in contract state
        async function checkForContractChanges() {
            if (!greenDishContract || accounts.length === 0) return;

            try {
                // Get dishes created by the restaurant owner
                const ownerDishes = await greenDishContract.methods.getRestaurantDishes(accounts[0]).call();

                // Check if number of dishes has changed
                if (ownerDishes.length !== deployedDishes.length) {
                    console.log('Detected dish count change, refreshing data...');
                    loadRestaurantData();
                    return;
                }

                // Check if any dish details have changed (like inventory or status)
                if (deployedDishes.length > 0) {
                    for (const dishId of ownerDishes) {
                        try {
                            const dishInfo = await greenDishContract.methods.getDishInfo(dishId).call();

                            // Find this dish in our local array
                            const existingDish = deployedDishes.find(d => d.id === dishId);

                            if (existingDish) {
                                // Check if status or inventory changed
                                const newAvailableInventory = dishInfo[4];
                                const newIsActive = dishInfo[8];

                                if (existingDish.availableInventory !== newAvailableInventory ||
                                    existingDish.isActive !== newIsActive) {
                                    console.log('Detected dish property change, refreshing data...');
                                    loadRestaurantData();
                                    return;
                                }
                            }
                        } catch (error) {
                            console.error(`Error checking dish ${dishId}:`, error);
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking for contract changes:', error);
                // Show network warning if we can't connect
                if (error.message && (
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('connection') ||
                    error.message.includes('network') ||
                    error.message.includes('Invalid JSON RPC response')
                )) {
                    document.getElementById('network-warning').style.display = 'block';
                }
            }
        }

        // Simplified refreshDishStatuses function
        async function refreshDishStatuses() {
            if (accounts.length === 0 || deployedDishes.length === 0) {
                return;
            }

            try {
                // Just reload the entire restaurant data instead of individual status checks
                await loadRestaurantData();
                showAlert("Dish statuses refreshed from blockchain", "info");
            } catch (error) {
                console.error("Error refreshing dish statuses:", error);
            }
        }

        // Carbon Credit Report Functions
        document.getElementById('generate-report').addEventListener('click', generateCarbonReport);

        // Function to generate a carbon report based on current dish data
        async function generateCarbonReport() {
            if (accounts.length === 0 || !greenDishContract) {
                showAlert("Please connect your wallet first", "error");
                return;
            }

            if (deployedDishes.length === 0) {
                showAlert("You haven't created any dishes yet", "warning");
                return;
            }

            showAlert("Generating carbon credits report... This may take a moment.", "info");

            // Clear existing purchase events
            purchaseEvents = [];
            let totalCarbonCredits = 0;
            let totalDishesSold = 0;
            let customerAddresses = new Set();

            // Add the restaurant's own address to the set to start
            customerAddresses.add("Multiple buyers");

            // Create a log of what we're doing for debugging
            console.log("======= GENERATING CARBON REPORT =======");

            try {
                // First, get the restaurant's carbon impact directly from the contract
                const tierInfo = await greenDishContract.methods.getRestaurantLoyaltyInfo(accounts[0]).call();
                const carbonImpact = parseInt(tierInfo[2]) || 0;

                console.log("Restaurant carbon impact from contract:", carbonImpact);
                console.log("Restaurant tier info:", tierInfo);

                // If we have a carbon impact, use it as our primary source of truth
                totalCarbonCredits = carbonImpact;

                // Log all dishes and their current state
                console.log("Dishes in inventory:");
                deployedDishes.forEach(dish => {
                    console.log(`- ${dish.name}: Initial=${dish.totalSeats}, Available=${dish.availableInventory}, Credits=${dish.carbonCredits}`);
                });

                // For each dish, calculate the sold inventory and carbon credits
                let hasGeneratedPurchaseEvents = false;

                for (const dish of deployedDishes) {
                    // Calculate sold inventory: initial inventory - current inventory
                    const initialInventory = parseInt(dish.totalSeats) || parseInt(dish.availableInventory) || 0;
                    const availableInventory = parseInt(dish.availableInventory) || 0;
                    const soldCount = initialInventory - availableInventory;
                    const carbonCreditsPerDish = parseInt(dish.carbonCredits) || 0;

                    console.log(`Report - Dish ${dish.name}: Initial=${initialInventory}, Available=${availableInventory}, Sold=${soldCount}, Credits=${carbonCreditsPerDish}`);

                    if (soldCount > 0) {
                        totalDishesSold += soldCount;
                        const estimatedCarbonCredits = carbonCreditsPerDish * soldCount;

                        // Add a record to the purchase events array
                        purchaseEvents.push({
                            dishName: dish.name,
                            buyer: "Multiple buyers (estimated)",
                            quantity: soldCount.toString(),
                            carbonCredits: estimatedCarbonCredits.toString(),
                            date: new Date().toLocaleString(),
                            timestamp: Date.now(),
                            isEstimate: true
                        });

                        hasGeneratedPurchaseEvents = true;

                        // Log the dish sale data for the visualization
                        console.log(`Adding dish to report: ${dish.name}, Sold: ${soldCount}, Credits: ${estimatedCarbonCredits}`);
                    }
                }

                // If we didn't generate any purchase events but we have carbon credits, 
                // create a generic purchase event for the chart to use
                if (!hasGeneratedPurchaseEvents && carbonImpact > 0) {
                    // Create a single entry for the total carbon impact
                    purchaseEvents.push({
                        dishName: "Total Restaurant Impact",
                        buyer: "Multiple buyers (estimated)",
                        quantity: "N/A",
                        carbonCredits: carbonImpact.toString(),
                        date: new Date().toLocaleString(),
                        timestamp: Date.now(),
                        isEstimate: true
                    });

                    // Make sure we have a non-zero total dishes sold if we have carbon credits
                    if (totalDishesSold === 0) {
                        totalDishesSold = 1; // Just to avoid division by zero
                    }

                    console.log("Created fallback purchase event for total carbon impact:", carbonImpact);
                }

                // Update the UI with the data
                document.getElementById('total-carbon-credits').textContent = totalCarbonCredits;
                document.getElementById('total-dishes-sold').textContent = totalDishesSold;

                // Remove reference to non-existent element
                // document.getElementById('unique-customers').textContent = customerAddresses.size;

                // Calculate average
                const avgCredits = totalDishesSold > 0 ? (totalCarbonCredits / totalDishesSold).toFixed(2) : 0;

                // Make sure this element exists in the HTML or skip it
                const avgCarbonCreditsElement = document.getElementById('avg-carbon-credits');
                if (avgCarbonCreditsElement) {
                    avgCarbonCreditsElement.textContent = avgCredits;
                }

                // Add a summary line to help with debugging
                console.log(`Generated carbon report: Total Credits=${totalCarbonCredits}, Total Sold=${totalDishesSold}, Events=${purchaseEvents.length}`);

                // Populate the transactions table
                renderTransactionsTable();

                // Show export options
                document.getElementById('export-options').style.display = 'block';

                // Create a basic chart visualization
                createCarbonCreditsChart();

                showAlert("Carbon credits report generated successfully!", "success");
            } catch (error) {
                console.error("Error generating carbon report:", error);
                showAlert("Error generating report: " + error.message, "error");
            }
        }

        // Function to render the transactions table
        function renderTransactionsTable() {
            const tableBody = document.getElementById('carbon-transactions');
            if (!tableBody) {
                console.error("Transaction table body not found");
                return;
            }

            // Sort by date, newest first
            purchaseEvents.sort((a, b) => b.timestamp - a.timestamp);

            // Check if we have purchase events
            if (purchaseEvents.length === 0) {
                // If we have no purchase events, check if we have carbon credits
                const totalCarbonCredits = parseInt(document.getElementById('total-carbon-credits').textContent) || 0;

                if (totalCarbonCredits > 0) {
                    // Create a row for the total carbon credits
                    tableBody.innerHTML = `
                    <tr class="table-warning">
                        <td>Total Restaurant Impact</td>
                        <td>Multiple buyers</td>
                        <td>N/A</td>
                        <td>${totalCarbonCredits}</td>
                        <td>${new Date().toLocaleString()}</td>
                    </tr>`;
                } else {
                    // No credits, no transactions
                    tableBody.innerHTML = `<tr><td colspan="5" style="text-align: center;">No transactions found</td></tr>`;
                }
                return;
            }

            let html = '';

            for (const event of purchaseEvents) {
                // Abbreviate buyer address
                const shortBuyer = event.isEstimate ? event.buyer :
                    `${event.buyer.substring(0, 6)}...${event.buyer.substring(38)}`;

                html += `
                <tr ${event.isEstimate ? 'class="table-warning"' : ''}>
                    <td>${event.dishName}</td>
                    <td>${shortBuyer}</td>
                    <td>${event.quantity}</td>
                    <td>${event.carbonCredits}</td>
                    <td>${event.date}</td>
                </tr>
                `;
            }

            tableBody.innerHTML = html;
        }

        // Function to create a simple chart visualization
        function createCarbonCreditsChart() {
            const chartContainer = document.getElementById('carbon-credits-chart');

            if (!chartContainer) {
                console.error("Chart container not found");
                return;
            }

            // Get the total carbon impact from the DOM
            const totalCarbonCredits = parseInt(document.getElementById('total-carbon-credits').textContent) || 0;

            console.log("Creating chart with total carbon credits:", totalCarbonCredits);

            // If we don't have any carbon credits, show a message
            if (totalCarbonCredits <= 0) {
                chartContainer.innerHTML = `
                <div style="text-align: center; padding: 50px;">
                    <p>No carbon credits found for visualization.</p>
                </div>`;
                return;
            }

            // Create dish credit data directly from the deployedDishes array
            const dishCredits = {};

            // If we have purchase events, use them
            if (purchaseEvents.length > 0) {
                purchaseEvents.forEach(event => {
                    const dishName = event.dishName || "Unknown Dish";
                    const credits = parseInt(event.carbonCredits) || 0;

                    if (!dishCredits[dishName]) {
                        dishCredits[dishName] = 0;
                    }
                    dishCredits[dishName] += credits;
                });
            }
            // If no purchase events but we have carbon credits, create a data point from contract data
            else if (totalCarbonCredits > 0) {
                // Create data for each dish with some inventory sold
                deployedDishes.forEach(dish => {
                    const initialInventory = parseInt(dish.totalSeats) || 0;
                    const availableInventory = parseInt(dish.availableInventory) || 0;
                    const soldCount = initialInventory - availableInventory;

                    if (soldCount > 0) {
                        const dishName = dish.name || "Unknown Dish";
                        const carbonCreditsPerDish = parseInt(dish.carbonCredits) || 0;
                        const estimatedCredits = carbonCreditsPerDish * soldCount;

                        if (!dishCredits[dishName]) {
                            dishCredits[dishName] = 0;
                        }
                        dishCredits[dishName] += estimatedCredits;
                    }
                });

                // If we still have no data but have total credits, create a single data point
                if (Object.keys(dishCredits).length === 0 && totalCarbonCredits > 0) {
                    dishCredits["Total Restaurant Impact"] = totalCarbonCredits;
                }
            }

            // Find the max value for scaling
            let maxCredits = 0;
            Object.values(dishCredits).forEach(credits => {
                maxCredits = Math.max(maxCredits, credits);
            });

            console.log("Chart data prepared:", dishCredits, "Max:", maxCredits);

            // Create HTML for the chart
            let barsHtml = '';

            Object.keys(dishCredits).forEach((dishName, index) => {
                const credits = dishCredits[dishName];
                const height = maxCredits > 0 ? (credits / maxCredits * 80) : 0; // Use 80% of height for better visualization
                const color = getColorForIndex(index);

                barsHtml += `
                <div style="display: flex; flex-direction: column; align-items: center; margin: 0 15px; flex: 1;">
                    <div style="display: flex; flex-direction: column; justify-content: flex-end; height: 180px;">
                        <div style="height: ${height}%; width: 40px; background-color: ${color}; min-height: 20px; transition: height 0.5s ease;"></div>
                </div>
                    <div style="margin-top: 10px; font-size: 14px; max-width: 120px; text-align: center; height: 40px; overflow: hidden;">${dishName}</div>
                    <div style="font-weight: bold; margin-top: 5px;">${credits} credits</div>
                </div>`;
            });

            // Set the HTML for the chart
            chartContainer.innerHTML = `
            <div style="text-align: center;">
                <h4>Carbon Credits by Dish</h4>
                <div style="display: flex; margin-top: 20px; padding: 10px; justify-content: center;">
                    ${barsHtml || '<p>No data available for chart</p>'}
                </div>
            </div>`;
        }

        // Helper function to get a color based on index
        function getColorForIndex(index) {
            const colors = ['#27ae60', '#2980b9', '#8e44ad', '#f39c12', '#c0392b', '#16a085'];
            return colors[index % colors.length];
        }

        // Export functions
        document.getElementById('export-csv').addEventListener('click', exportCarbonReportCSV);

        // Function to export carbon report as CSV
        function exportCarbonReportCSV() {
            if (purchaseEvents.length === 0) {
                showAlert("No data to export", "error");
                return;
            }

            // Create CSV content
            let csv = 'Dish Name,Buyer Address,Quantity,Carbon Credits,Date\n';

            purchaseEvents.forEach(event => {
                csv += `"${event.dishName}","${event.buyer}",${event.quantity},${event.carbonCredits},"${event.date}"\n`;
            });

            // Create download link
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `carbon-credits-report-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showAlert("CSV file exported successfully", "success");
        }

        // Create dish function
        async function createDish() {
            if (!greenDishContract || accounts.length === 0) {
                showAlert("Please connect your wallet first", "error");
                return;
            }

            // Check contract validity first
            try {
                // Simple call to check if contract is accessible
                await greenDishContract.methods.dishCount().call();
            } catch (error) {
                document.getElementById('network-warning').style.display = 'block';
                showAlert("Cannot connect to the GreenDish contract. Please check your network settings in MetaMask.", "error");
                console.error("Contract connection error:", error);
                return;
            }

            // Get input values
            const restaurantName = restaurantNameInput.value.trim();
            const dishName = dishNameInput.value.trim();
            const dishPrice = dishPriceInput.value.trim();
            const inventory = inventoryInput.value.trim();
            const carbonCredits = carbonCreditsInput.value.trim();
            const mainComponent = mainComponentInput.value.trim();
            const supplySource = supplySourceInput.value.trim();

            // Validate inputs
            if (!restaurantName || !dishName || !dishPrice || !inventory || !carbonCredits || !mainComponent || !supplySource) {
                showAlert("Please fill in all fields", "error");
                return;
            }

            if (parseFloat(dishPrice) <= 0) {
                showAlert("Dish price must be greater than 0", "error");
                return;
            }

            if (parseInt(inventory) <= 0 || parseInt(inventory) > 10000) {
                showAlert("Inventory must be between 1 and 10000", "error");
                return;
            }

            if (parseInt(carbonCredits) < 0 || parseInt(carbonCredits) > 100) {
                showAlert("Carbon credits must be between 0 and 100", "error");
                return;
            }

            try {
                // Convert ETH price to wei
                const dishPriceWei = web3.utils.toWei(dishPrice, 'ether');

                showAlert("Creating dish... Please confirm the transaction in MetaMask", "info");

                console.log("Contract address being used:", GreenDishConfig.addresses.GreenDish);
                console.log("Creating dish with params:", {
                    restaurantName,
                    dishName,
                    dishPriceWei,
                    inventory,
                    carbonCredits,
                    mainComponent,
                    supplySource
                });

                // Call smart contract function
                const tx = await greenDishContract.methods.createDish(
                    restaurantName,
                    dishName,
                    dishPriceWei,
                    inventory,
                    carbonCredits,
                    mainComponent,
                    supplySource
                ).send({
                    from: accounts[0],
                    gas: 500000, // Explicit gas limit to avoid out of gas errors
                });

                console.log("Transaction submitted:", tx.transactionHash);
                showAlert(`Dish "${dishName}" created successfully!`, "success");

                // Save restaurant name to localStorage
                saveRestaurantName(restaurantName);

                // Store the initial inventory value - we need to get the dish ID first
                try {
                    // Get the dishes owned by this restaurant
                    const dishIds = await greenDishContract.methods.getRestaurantDishes(accounts[0]).call();
                    console.log("Restaurant dishes after creation:", dishIds);

                    if (dishIds && dishIds.length > 0) {
                        // The newest dish is the last one in the array
                        const newDishId = dishIds[dishIds.length - 1];

                        // Load existing saved inventory data
                        let savedInitialInventory = {};
                        const savedData = localStorage.getItem(`initialInventory_${accounts[0].toLowerCase()}`);
                        if (savedData) {
                            savedInitialInventory = JSON.parse(savedData);
                        }

                        // Save the initial inventory for the new dish
                        savedInitialInventory[newDishId] = inventory;
                        localStorage.setItem(`initialInventory_${accounts[0].toLowerCase()}`, JSON.stringify(savedInitialInventory));
                        console.log(`Saved initial inventory for new dish ${newDishId}: ${inventory}`);
                    }
                } catch (e) {
                    console.error("Error saving initial inventory for new dish:", e);
                }

                // Clear form except for restaurant name
                dishNameInput.value = '';
                dishPriceInput.value = '';
                inventoryInput.value = '';
                carbonCreditsInput.value = '';
                mainComponentInput.value = '';
                supplySourceInput.value = '';

                // Reload restaurant data
                await loadRestaurantData();

            } catch (error) {
                console.error("Error creating dish:", error);

                let errorMessage = "Error creating dish";

                // Check for specific error types
                if (error.code === 4001) {
                    errorMessage = "Transaction was rejected in MetaMask";
                } else if (error.message && error.message.includes("gas")) {
                    errorMessage = "Transaction may have run out of gas. Try setting a higher gas limit.";
                } else if (error.message && error.message.includes("execution reverted")) {
                    errorMessage = "Contract execution reverted. This might be due to contract restrictions.";
                } else if (error.message) {
                    errorMessage += ": " + error.message;
                }

                showAlert(errorMessage, "error");

                // Show network warning if appropriate
                if (error.message && (
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('connection') ||
                    error.message.includes('network') ||
                    error.message.includes('Invalid JSON RPC response')
                )) {
                    document.getElementById('network-warning').style.display = 'block';
                }
            }
        }

        // Save restaurant name to localStorage
        function saveRestaurantName(name) {
            if (accounts.length > 0 && name) {
                const restaurantInfo = {
                    name: name,
                    lastUpdated: new Date().toISOString()
                };
                localStorage.setItem(`restaurantInfo_${accounts[0].toLowerCase()}`, JSON.stringify(restaurantInfo));

                // Make the field readonly to prevent accidental changes
                restaurantNameInput.setAttribute('readonly', true);

                // Add a button to allow changing the name if needed
                const nameContainer = restaurantNameInput.parentElement;
                if (!document.getElementById('change-name-btn')) {
                    const changeNameBtn = document.createElement('button');
                    changeNameBtn.id = 'change-name-btn';
                    changeNameBtn.className = 'btn btn-secondary';
                    changeNameBtn.style.marginTop = '10px';
                    changeNameBtn.textContent = 'Change Restaurant Name';
                    changeNameBtn.addEventListener('click', function () {
                        restaurantNameInput.removeAttribute('readonly');
                        restaurantNameInput.focus();
                        this.style.display = 'none';
                    });
                    nameContainer.appendChild(changeNameBtn);
                }
            }
        }

        // Save deployed dishes data
        function saveDeployedDishes() {
            localStorage.setItem('deployedDishes', JSON.stringify(deployedDishes));
        }

        // Function to check contract addresses and display debug info
        async function checkContractAddresses() {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = 'block';
            debugInfo.innerHTML = 'Loading contract address info...';

            try {
                // Get addresses from config
                const configAddresses = {
                    greenCoin: GreenDishConfig.addresses.GreenCoin,
                    greenDish: GreenDishConfig.addresses.GreenDish
                };

                // Get addresses from deployments.json
                let deploymentAddresses = {};
                try {
                    const response = await fetch('/deployments.json');
                    if (response.ok) {
                        const data = await response.json();
                        deploymentAddresses = {
                            greenCoin: data.greenCoinAddress,
                            greenDish: data.greenDishAddress
                        };
                    } else {
                        deploymentAddresses = { error: "Could not load deployments.json" };
                    }
                } catch (e) {
                    deploymentAddresses = { error: `Error loading deployments.json: ${e.message}` };
                }

                // Check code at addresses
                let codeCheck = {};
                if (window.web3) {
                    try {
                        const greenCoinCode = await window.web3.eth.getCode(configAddresses.greenCoin);
                        const greenDishCode = await window.web3.eth.getCode(configAddresses.greenDish);

                        codeCheck = {
                            greenCoin: {
                                address: configAddresses.greenCoin,
                                hasCode: greenCoinCode !== '0x' && greenCoinCode !== '0x0'
                            },
                            greenDish: {
                                address: configAddresses.greenDish,
                                hasCode: greenDishCode !== '0x' && greenDishCode !== '0x0'
                            }
                        };
                    } catch (e) {
                        codeCheck = { error: `Error checking code: ${e.message}` };
                    }
                } else {
                    codeCheck = { error: "Web3 not initialized" };
                }

                // Check network connection
                let networkInfo = {};
                if (window.web3) {
                    try {
                        const networkId = await window.web3.eth.net.getId();
                        const chainId = await window.web3.eth.getChainId();
                        networkInfo = {
                            networkId,
                            chainId,
                            isLocal: networkId === 31337 || networkId === 1337
                        };
                    } catch (e) {
                        networkInfo = { error: `Error getting network info: ${e.message}` };
                    }
                } else {
                    networkInfo = { error: "Web3 not initialized" };
                }

                // Format debug info
                let html = '<strong>Contract Address Check</strong><br>';
                html += '<hr>';

                html += '<strong>Network:</strong><br>';
                if (networkInfo.error) {
                    html += `Error: ${networkInfo.error}<br>`;
                } else {
                    html += `Network ID: ${networkInfo.networkId}<br>`;
                    html += `Chain ID: ${networkInfo.chainId}<br>`;
                    html += `Is Local Hardhat: ${networkInfo.isLocal ? 'Yes ✅' : 'No ❌'}<br>`;

                    if (!networkInfo.isLocal) {
                        html += '<span style="color: red; font-weight: bold;">Wrong network! Connect to Localhost:8545</span><br>';
                    }
                }
                html += '<hr>';

                html += '<strong>Config Addresses:</strong><br>';
                html += `GreenCoin: ${configAddresses.greenCoin}<br>`;
                html += `GreenDish: ${configAddresses.greenDish}<br>`;
                html += '<hr>';

                html += '<strong>Deployment File:</strong><br>';
                if (deploymentAddresses.error) {
                    html += `Error: ${deploymentAddresses.error}<br>`;
                } else {
                    html += `GreenCoin: ${deploymentAddresses.greenCoin}<br>`;
                    html += `GreenDish: ${deploymentAddresses.greenDish}<br>`;

                    const coinMatch = configAddresses.greenCoin === deploymentAddresses.greenCoin;
                    const dishMatch = configAddresses.greenDish === deploymentAddresses.greenDish;

                    html += `Config matches deployment file: ${coinMatch && dishMatch ? 'Yes ✅' : 'No ❌'}<br>`;
                }
                html += '<hr>';

                html += '<strong>Contract Code Check:</strong><br>';
                if (codeCheck.error) {
                    html += `Error: ${codeCheck.error}<br>`;
                } else {
                    html += `GreenCoin at ${codeCheck.greenCoin.address} has code: ${codeCheck.greenCoin.hasCode ? 'Yes ✅' : 'No ❌'}<br>`;
                    html += `GreenDish at ${codeCheck.greenDish.address} has code: ${codeCheck.greenDish.hasCode ? 'Yes ✅' : 'No ❌'}<br>`;
                }

                debugInfo.innerHTML = html;
            } catch (error) {
                debugInfo.innerHTML = `Error running diagnostic: ${error.message}`;
            }
        }

        // Add a function to reset connection
        async function resetAndReconnect() {
            try {
                // Clear any cached data
                localStorage.removeItem('deployedDishes');

                // Reload contract config
                await GreenDishConfig.loadDeploymentAddresses();

                // Reinitialize Web3
                if (window.ethereum) {
                    try {
                        // Clear any existing connection
                        if (window.web3) {
                            window.web3 = null;
                        }

                        // Reset accounts
                        accounts = [];

                        // Force page reload to reset everything
                        window.location.reload();
                    } catch (error) {
                        console.error("Error resetting connection:", error);
                        showAlert("Error resetting connection. Please try refreshing the page.", "error");
                    }
                }
            } catch (error) {
                console.error("Error in reset and reconnect:", error);
                showAlert("Reset failed: " + error.message, "error");
            }
        }

        // Hard reset function to completely reset everything
        function hardReset() {
            try {
                // Clear all localStorage data
                localStorage.clear();

                // Force disconnect from MetaMask
                if (window.ethereum && window.ethereum.disconnect) {
                    window.ethereum.disconnect();
                }

                // Force clear any Web3 instances
                window.web3 = null;

                // Set the correct contract addresses directly in URL parameters
                const correctGreenDishAddress = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512';
                const correctGreenCoinAddress = '0x5FbDB2315678afecb367f032d93F642f64180aa3';

                // Reload the page with force parameters
                window.location.href = `${window.location.pathname}?forceReset=true&greenDishAddress=${correctGreenDishAddress}&greenCoinAddress=${correctGreenCoinAddress}&t=${Date.now()}`;
            } catch (error) {
                console.error("Hard reset error:", error);
                alert("Hard reset failed. Please try refreshing the page manually.");
            }
        }

        // Function to read address parameters from URL
        function readAddressFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const forceReset = urlParams.get('forceReset') === 'true';

            if (forceReset) {
                // Get addresses from URL
                const greenDishAddress = urlParams.get('greenDishAddress');
                const greenCoinAddress = urlParams.get('greenCoinAddress');

                if (greenDishAddress && greenCoinAddress) {
                    console.log("Forcing contract addresses from URL parameters:");
                    console.log("- GreenDish:", greenDishAddress);
                    console.log("- GreenCoin:", greenCoinAddress);

                    // Update the GreenDishConfig addresses
                    GreenDishConfig.addresses.GreenDish = greenDishAddress;
                    GreenDishConfig.addresses.GreenCoin = greenCoinAddress;

                    // Show alert to user
                    showAlert("Contract addresses have been reset to the correct values", "success");
                }
            }
        }

        // Call the URL check on page load
        document.addEventListener('DOMContentLoaded', function () {
            readAddressFromURL();
        });

        // Helper function to get all customers who purchased a specific dish
        async function getCustomersForDish(dishId) {
            // In a real implementation, you might query transaction logs or events
            // For this solution, we'll use a placeholder approach
            // One approach would be to get past events from the contract, but that's complex in this context

            // For now, we'll rely on the data from the carbon report which has purchase info
            const customers = new Set();

            try {
                // Check if we have purchase events data
                if (purchaseEvents && purchaseEvents.length > 0) {
                    for (const event of purchaseEvents) {
                        if (event.dishId == dishId) {
                            customers.add(event.customer);
                        }
                    }
                }
            } catch (error) {
                console.error("Error getting customers for dish:", error);
            }

            return Array.from(customers);
        }

        // Function to count actual sales from dish purchases
        async function countActualSales() {
            if (!greenDishContract || accounts.length === 0) return 0;

            actualSalesCount = 0;
            try {
                const restaurantDishes = await greenDishContract.methods.getRestaurantDishes(accounts[0]).call();

                // Check for transaction events to count actual sales
                for (let i = 0; i < restaurantDishes.length; i++) {
                    const dishId = restaurantDishes[i];
                    // Get actual sales by checking blockchain records
                    try {
                        const customers = await getCustomersForDish(dishId);
                        for (const customer of customers) {
                            try {
                                const purchaseCount = await greenDishContract.methods.dishesBought(dishId, customer).call();
                                actualSalesCount += parseInt(purchaseCount);
                            } catch (err) {
                                console.log(`No purchase data for customer ${customer} and dish ${dishId}`);
                            }
                        }
                    } catch (error) {
                        console.error("Error getting actual sales count:", error);
                    }
                }

                // Update the display
                const actualSalesElement = document.getElementById('actual-sales');
                if (actualSalesElement) {
                    actualSalesElement.textContent = actualSalesCount;
                }

                return actualSalesCount;
            } catch (error) {
                console.error("Error counting actual sales:", error);
                return 0;
            }
        }

        // Modify the loadRestaurantData function to include actual sales counting
        async function loadRestaurantData() {
            if (!greenDishContract || !accounts.length) return;

            try {
                // Get dishes created by the restaurant owner
                const ownerDishes = await greenDishContract.methods.getRestaurantDishes(accounts[0]).call();
                console.log("Restaurant dishes:", ownerDishes);

                // Load restaurant loyalty tier info
                loadRestaurantTierInfo();

                // Count actual sales if the element exists
                if (document.getElementById('actual-sales')) {
                    await countActualSales();
                }

                // Reset dishes array
                deployedDishes = [];

                // Load saved initial inventory data if available
                let savedInitialInventory = {};
                try {
                    const savedData = localStorage.getItem(`initialInventory_${accounts[0].toLowerCase()}`);
                    if (savedData) {
                        savedInitialInventory = JSON.parse(savedData);
                        console.log("Loaded saved initial inventory:", savedInitialInventory);
                    }
                } catch (e) {
                    console.error("Error loading saved inventory data:", e);
                }

                // Load dish details
                if (ownerDishes.length > 0) {
                    let restaurantNameFromChain = null;

                    for (const dishId of ownerDishes) {
                        try {
                            const dishInfo = await greenDishContract.methods.getDishInfo(dishId).call();
                            console.log(`Dish ${dishId} info:`, dishInfo);

                            // Store restaurant name from first dish if we don't have it yet
                            if (!restaurantNameFromChain && dishInfo[0]) {
                                restaurantNameFromChain = dishInfo[0];
                            }

                            const dish = {
                                id: dishId,
                                restaurantName: dishInfo[0],
                                restaurantOwner: dishInfo[1],
                                name: dishInfo[2],
                                dishPrice: web3.utils.fromWei(dishInfo[3], 'ether'),
                                availableInventory: dishInfo[4],
                                carbonCredits: dishInfo[5],
                                mainComponent: dishInfo[6],
                                supplySource: dishInfo[7],
                                isActive: dishInfo[8]
                            };

                            // If we have saved initial inventory, use it
                            // Otherwise, use current inventory as the initial value
                            if (savedInitialInventory[dishId]) {
                                dish.totalSeats = savedInitialInventory[dishId];
                            } else {
                                // This is a new dish or we don't have saved data
                                // Save the current inventory as the initial value
                                dish.totalSeats = dish.availableInventory;
                                savedInitialInventory[dishId] = dish.availableInventory;
                            }

                            deployedDishes.push(dish);
                        } catch (error) {
                            console.error(`Error loading dish ${dishId}:`, error);
                        }
                    }

                    // Save the updated initial inventory values to localStorage
                    try {
                        localStorage.setItem(`initialInventory_${accounts[0].toLowerCase()}`, JSON.stringify(savedInitialInventory));
                    } catch (e) {
                        console.error("Error saving inventory data:", e);
                    }

                    // If we found a restaurant name on-chain but don't have one saved, save it
                    if (restaurantNameFromChain) {
                        const savedData = localStorage.getItem(`restaurantInfo_${accounts[0].toLowerCase()}`);
                        if (!savedData) {
                            saveRestaurantName(restaurantNameFromChain);
                            showAlert(`Retrieved your restaurant name "${restaurantNameFromChain}" from your existing dishes`, "info");
                        }
                    }

                    // Update UI
                    renderDishList();
                    updateDashboardStats();

                    showAlert(`Loaded ${deployedDishes.length} dishes`, "success");
                } else {
                    dishList.innerHTML = "<p>No dishes created yet</p>";
                    updateDashboardStats();
                }
            } catch (error) {
                console.error("Error loading restaurant data:", error);
                showAlert("Error loading restaurant data: " + error.message, "error");
            }
        }
    </script>
</body>

</html>